<!-- 해당 챕터를 정리한 내용을 적어주세요 -->

# 6.1 번들링은 무엇이고 왜 필요할까?

> **번들링이란?** <br/>
> 여러 개로 구성된 소스파일을 한 개 또는 그 이상의 작은 단위로 합쳐서 제공하는 것

**번들링이 필요한 이유**

1. 성능개선: 번들링 과정을 거쳐 하나의 파일만 다운로드할 수 있다면 여러 개의 파일을 별도로 받는 것보다 웹사이트를 불러오는 속도가 빨라질 것.
2. 파일 크기 최적화: 변수명이 짧고, 줄바꿈이 적고, 불필요한 공뱅이 없을수록 파일을 다운로드하기 쉽고 머신이 자바스크립트 파일을 해석하는데 도움이 됨
3. 호환성 문제 해결: 다양한 모듈 형식이 브라우저와 같은 환경에서 이해할 수 있는 단 하나의 형식으로 통일해줌
4. 다른 개발 도구와의 통합: 바벨, 타입스크립트,SCSS등 다양한 도구와 함께 사용할 수 있도록 해줌.

번들러는 개발에서 꼭 중요한 도구이지만 Next.js와 같은 프레임워크에서 처리되어 어떤 라이브러리가 어떻게 처리하는지 모르는 경우가 많음

## 6.1.1 번들링의 역사

### 6.1.1.1 초기 자바스크립트 환경

자바스크립트가 처음 등장한 1995년은 대부분 HTML로 구성되어있었고 자바스크립트는 아주 간단한 상호작용을 위한 정도로만 사용

- 자바스크립트를 불러오는 `<script />`가 적기 떄문에 웹사이트에서 필요한 대부분의 작업을 처리할 수 있었음

그러나 브라우저와 컴퓨터의 성능이 좋아지며 더 많은 인터랙션을 자바스크립트로 처리하기 시작했고 아래와 같은 문제가 발생

1. 파일 분리의 모호함 : 관리해야할 코드가 많아지며 실제 웹사이트로 배포해야할 스크립트를 어떤 기준으로 삽입할지 판단이 어려움
   - 웹사이트가 처리해야할 자바스크립트가 많더라도 하나의 파일로 모든 것을 관리할 것인가? 각 자바스크립트의 실행시점이 다르다면 어떻게 할 것인가? 어떤 기준으로 파일을 분리할 것인가? 이러한 결정을 매번 개발자가 인지하고 처리할 수 있을까?
2. 성능저하: 명확한 기준 없이 로드해야하는 스크립트가 많아진다면 웹사이트의 성능 저하를 야기
   - 여러개의 자바스크립트를 나눠서 삽입할 경우 다수의 스크립트 파일을 다운로드하고 실행하는 작업을 순차적으로 로드해야 하기 때문에 로딩시간이 길어짐
3. 전역 네임스페이스 오염: 과거 자바스크립트에서는 모듈 시스템이라는 개념이 없었기 때문에 서로 다른 스크립트에서 동일한 변수나 함수를 선언할 경우 변수 충돌의 위험이 매우 큼
4. 복잡한 의존성 관리: 특정 라이브러리 간에 의존성 관계가 존재하는 경우 이를 코드 내에서 잘 표현해야함.
5. 불편한 개발 경험: 여러 개로 구성된 자바스크립트 파일을 HTML 리소스로 만들기 위해서는 의존성 순서 조정, 파일 여러개를 하나로 합치거나 경우에 따라서는 JSON과 이미지를 불러와야하고 전역 네임스페이스 관리까지 해야함

이런 문제를 효율적으로 해결하기 위해 번들과 기타 여러 가지 작업을 도맡아 하는 라이브러리가 등장

### 6.1.1.2 번들 라이브러리의 등장

#### 6.1.1.2.1 Browserify(2011)

commonJs를 브라우저에서도 사용하기 위해 탄생한 라이브러리
모든 require()함수의 호출을 재귀적으로 분석해 브라우저에서 하나의 `<script>`태그로 사용할 수 있도록 번들 생성

- 전역 네임스페이스 오염을 방지하기 위해 파일 전체를 하나의 즉시 실행 함수로 구성

장점: 간단한 사용법, 다양한 플러그인과 트랜스폼을 통한 확장 용이, require코드를 알아서 분석해 하나의 모듈로 만들어줌

단점: require을 살리지 않으면서 더욱 빠르게 번들링하는 도구의 등장,
트랜스폼과 플로그인이 많아질 수록 복잡해지는 코드, 파일 수정을 즉시 확인해서 새로하는 번들하는 도구(HMR)을 사용하려면 별도 도구 사용해야함

현재는 ESModule의 import 구문을 사용하는 추세라 2020년 17버전 이후 정식 버전이 올라오지 않음

#### 6.1.1.2.2 webpack(2012)

번들 라이브러리가 가져야 할 기능, 구조 등을 만들면서 모던 웹 애플리케이션이 갖춰야 할 대부분의 기능을 제공

자바스크립트뿐만 아니라 HTML,CSS,이미지 등 기타 정적인 자원도 함께 번들링

기본적인 기능 뿐만아니라 다양한 플러그인도 제공하면서 웹서비스가 고려할 수 있는 대부분의 작업을 웹팩 내부에서 해결할 수 있도록 마련.

#### 6.1.1.2.3 Rollup(2015)

ES6 출시 당시 새롭게 표준화된 코드 모듈 형식인 ESModule을 번들링하기 위한 목적으로 탄생

ESModule기반으로 작성된 코드를 CommonJs, AMD 또는 즉시 실행 함수 스타일의 코드 등 원하는 방식으로 컴파일 가능 => 개발 경험 향상과 ESModule 특징을 취할 수 있음과 동시에 구형 시스템에서도 호환가능하도록 도와주는 것이 목적

#### 6.1.1.2.4 Parcel(2017)

매우 빠른 번들링 작업과 제로 설정 내지는 아주 간결한 설정만으로도 번들링 할 수 있게 해주는 도구
Parcel는 웹서비스에서 주로 사용되는 자원(HTML,CSS,이미지)에 대한 번들링을 내장하고 있기 때문에 별도의 설정이 필요없음

특징)

- 별도 구성 파일이 없어도 각 리소스에 맞는 처리를 자체적으로 내장하고 있어 별도의 최적화 코드를 작성하지 않아도 됨. 번들에 필요한 의존성도 시작파일을 기준으로 분석해줌
- 멀티코어 프로세서를 활용해 빌드 작업을 벙렬로 처리함으로써 빌드 속도가 매우 빠름. 이전 빌드 결과를 캐시해 변경된 파일만 다시 빌드(증분 빌드), 러스트로 작성되어있어 자바스크립트로 작성된 웹팩에 비해 빠름
- 정적 빌드가 가능해 불필요한 모듈 선언을 방지하고 사용하지 않는 코드를 최종 결과물에서 제거하는 트리셰이킹이 가능함.

CodeSandbox와 같이 가볍고 빠른 빌드가 필요한 온라인 IDE 서비스너 POC 성격의 서비스에서 폭넓게 사용중
세밀한 고급설정은 불가능하기에 복잡한 번들 시스템이 필요한 프레임워크 등에서는 웹팩이 더 자주 사용됨

#### 6.1.1.2.5 Vite(2020)

기존 번들러가 제공해야하는 필수 기능 등을 모두 달성함과 동시에 다른 번들러 대비 더 빠른 속도와 더불어 다양한 프레임워크를 지원
개발모드에서는 GO 언어를 기반으로 작성된 esbuild를, 프로덕션 모드로 빌드시 rollup을 사용한다.

## 6.1.2 번들링의 역할

### 6.1.2.1 코드 분할

필요한 경우

- 동적 로딩이 필요한 경우: 뒤늦게 불러와도 괜찮은 리소스의 로딩을 최대한 지연시키고 싶을 때 사용. 특정 조건에서만 로딩돼야 하는 코드나 사용자의 인터랙션이 실행되는 시점에 필요해지는 코드도 해당 조건을 만족하는 순간에 모듈을 불러오는 것이 효율적.
- 대규모 라이브러리를 사용해야할 경우: node_modules의 대형 라이브러리에 의존하고 있는 경우 별도 파일로 분리해서 필요한 시점에 불러오는 것이 성능상 이점이 있음
- 네트워크 오버헤드 감소: 경우에 따라서는 하나의 큰 파일을 다운로드하는 것보다 적당한 크기로 큰 파일을 쪼개서 다운로드하는 편이 이득일 수 있음

웹팩은 정적모듈 및 동적모듈에 코드 분할을 적용하거나 네트워크 오버헤드를 감소시키기 위한 목적으로 파일 크기를 제한하는 등 다양한 방법으로 코드 분할을 할 수 있도록 지원

### 6.1.2.2 트리 셰이킹

> 번들 결과물을 생성할 때 사용될 가능성이 없는 죽은 코드를 제거하는 것

어디에서도 호출되지 않거나 실행가능성 없는 코드는 트리 셰이킹을 해주지만 모든 경우 제거하는 것은 아니다.

```
// utils.js
export function usedF(){
    console.log('use!')
}

export function unusedF(){
    console.log('unused!')
}

console.log('hello')

// index.js
import {usedF} from './utils.js'

usedF()
```

여기에서 `console.log('hello')`는 직접적인 호출은 없더라도 import하는 순간에 호출되어있도록 만들어져있다. 모듈의 사이드 이펙트라고 하는데 이런 코드들은 제거되지 않는다.

### 6.1.2.3 난독화 및 압축

가독성을 위한 변수명이 자바스크립트 엔진 입장에서는 불필요한 파일 증가를 가져올 수 있다. 또한 자바스크립트는 브라우저의 개발자 도구로 손쉽게 접근 가능히 때문에 직접적으로 읽기 어려운 형식을 가지고 있어야한다.

소스코드를 보호하고 리소스 크기를 줄이기 위한 기능이다.

