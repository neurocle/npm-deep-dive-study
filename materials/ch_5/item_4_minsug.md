# 5.4 바벨과 core-js의 대안

바벨과 core-js는 폭넓은 호환성과 강력한 기능으로 웹 개발의 표준을 자리잡았지만 항상 최선의 선택은 아닐 수 있다.
어떤 대안이 있는지 한번 알아보자

## 5.4.1 타입스크립트 컴파일러

먼저 트랜스파일은 바벨 대신 타입스크립트 컴파일러를 사용할 수 있다.
타입스크립트 컴파일러는 정적 타입 검사뿐만 아니라 트랜스파일까지 수행한다.
이때 트랜스파일할 대상 버전은 `tsconfig.json`의 target에 지정하면 된다.

target이 받을 수 있는 버전

- ES3
- ES5
- ES6
- ES2016 ~ 2022
- ESNext

대부분의 경우 ES6이상을 쓰지 않을까 생각한다.

### 5.4.1.1 module

module을 지정할 수 도 있다.

- none: 컴파일된 코드에 모듈 시스템을 적용하지 않는다.
- preserve: 타입스크립트에서 사용된 모듈 구문을 그대로 유지한다.
- node16: 확장자에 따라 파일을 ESModule 또는 CommonJS 모듈로 처리한다.
- nodenext: Node.js에서 최신 모듈 시스템을 적용한다.
- commonjs, system, amd, umd: 이외에 직접 사용할 다른 모듈 시스템을 지정한다.
- es6/es2015: ES6 모듈 시스템을 사용하여 모듈 구문을 변경한다.
- es2020.es2022: ES2020 및 ES2022 모듈 시스템을 사용한다.

### 5.4.1.2 lib

lib 필드는 타입스크립트가 컴파일할 때 표준 라이브러리 목록을 지정하는 필드이다.

lib에는 ES5와 같은 ECMAscript 지정부터

- DOM
- WebWorker
- ScriptHost
- WebGL

같은 API 범위를 지정할 수 있다.

ex) lib: ["ESNext", "DOM"]

### 5.4.1.3 sourceMap

sourceMap 필드는 컴파일된 자바스크립트 파일에 소스맵을 생성할지 여부를 설정한다.

소스맵은 디버깅 시 원본 타입스크립트 코드와 트랜스파일된 자바스크립트 코드 간의 매핑을 제공함으로써 디버깅을 용이하게 해주는 객체 형태의 데이터를 의미한다.

### 5.4.1.4 jsx

타입스크립트 트랜스파일러는 jsx 문법도 트랜스파일할 수 있다.
설정은 다음과 같다.

- preserve: jsx 구문을 변환하지 않고 그대로 유지
- react: jsx 구문을 React.createElement() 함수 호출로 변환 - 해당 방식은 react 16 이전 버전에서 사용하는 방식으로 import React 필요
- react-jsx: 리액트 17 이상 버전에서 사용되는 새로운 jsx 변환 방식을 사용 - **import React 생략 가능**

### 5.4.1.5 타입스크립트 컴파일러와 바벨 비교

| 특징                             | 타입스크립트 컴파일러      | 바벨              |
| -------------------------------- | -------------------------- | ----------------- |
| 설정 편의성                      | 쉬움                       | 상대적으로 복잡함 |
| 소스맵 지원                      | 지원                       | 지원              |
| 코드 안정성 향상(정적 타입 검사) | 확인                       | 미확인            |
| 내장된 폴리필 제공               | 미제공                     | 제공              |
| 플러그인 생태계                  | 부족함                     | 풍부함            |
| 대규포 프로젝트 컴파일 속도      | 타입 검사로 인해 속도 느림 | 상대적으로 빠름   |

### 5.4.2 SWC(Speedy Web Compiler)

바벨의 대안으로 부상하고 있는 또 다른 트랜스파일러로 SWC가 있다.
SWC는 러스트로 개발된 고성능 트랜스파일러로, 바벨과 비교해서 상당히 빠른 속도를 잘한다.
그래서 대규모 프로젝트에서 빠른 트랜스파일이 가능하며 러스트의 메모리 안정성과 뛰어난 성능 덕분에 빌드 속도가 중요한 프로젝트에서 특히 유용하다.

### 5.4.2.1 SWC의 특징

- 바벨과의 호환성: SWC는 바벨과 굉장히 유사한 설정 방식을 지원하여, 바벨의 많은 플러그인을 대체할 수 있는 기능을 제공한다.
- 트리 셰이킹: SWC는 사용되지 않는 코드를 제거해서 최종 번들 크기를 줄이는 트리 셰이킹을 지원한다.
- 타입스크립트와의 강력한 통합: SWC는 타입스크립트를 완벽히 지원한다.
- 공식 스키마 제공: SWC는 구성파일 작성을 돕는 공식 JSON 스키마를 제공한다.

### 5.4.2.2 SWC와 바벨, 타입스크립트 컴파일러 비교

SWC는 타입스크립트 `tsconfig,json`을 작성하는 방식과 유사하게 .swcrc를 작성한다. 즉, 타입스크립트 설정의 간편함을 SWC에서 그대로 누릴 수 있다. 바벨과 유사하게 SWC는 env 필드를 통해 core-js와 같은 폴리필 기능도 사용이 가능하다.
결과적으로 SWC는 타입스크립트 컴파일러의 간단한 설정 방식과 바벨의 유연함을 유지하면서도 러스트의 뛰어난 성능까지 누릴 수 있다.

하지만 바벨만큼 플러그인 생태계가 풍부하지는 않다.

### 5.4.3 es-shims

core-js를 대신할 수 있는 폴리필 프로젝트인 es-shims를 알아보자.
es-shims 프로젝트는 ECMAScript 기능을 브라우저나 런타임 환경에서 부족한 부분을 보완하기 위해 폴리필을 제공하는 오픈소스 프로젝트로 자바스크립트 기능을 하위 호환성을 지원하지 않는 환경에서 사용할 수 있게하는 것을 목표로 한다.

### 5.4.3.1 core-js vs es-shims

core-js는 최신 사양과 실험적인 기능까지 폭넒게 지원하므로 폴리필 지원 범위가 매우 넓다. 반면 es-shims는 레거시 환경에서 안정적으로 동작하도록 설계됐기 때문에 실험적 기능 혹은 표준 기능보다 더 넓은 범위의 폴리필이 필요한 경우에는 적합하지 않을 수 있다.
또한 core-js는 트리 세이킹을 통해 필요한 코드만 번들에 포함시킬 수 있는 반면 es-shims는 패키지별로 모듈화돼 있으나 다음과 같은 이유로 필요없는 코드가 포함될 가능성이 있다.

- 사양 준수 목표
- 독립적인 패키지 설계
- 오래된 환경 지원
- 트리 세이킹 미지원

| 상황                      | core-js 크기                            | es-shims 크기                                   |
| ------------------------- | --------------------------------------- | ----------------------------------------------- |
| 모든 기능을 폴리필할 경우 | 모든 ECMASCript 기능이 포함되므로 더 큼 | 필요한 패키지만 추가해야 하므로 상대적으로 작음 |
| 특정 기능만 폴리필할 경우 | 트리 세이킹으로 크기 최적화 가능        | 패키지 단위로 로드되므로 불필요한 코드가 포함됨 |

### 5.4.4 polyfill.js

core-js를 대체하는 또 다른 프로젝트로 polyfill.js가 있다.
그런데 해당 라이브러리는 서빙 방식에 치명적인 문제가 있어 2024년 2월에 전 세계적인 서비스 장애를 겪았단 적이 있다.
