# npm의 문제점과 한계

npm은 15년 이상 자바스크립트 진영에서 꾸준히 사용되고 있지만 그만큼 문제도 많고 한계점도 명확하다.

한 번 알아보자.

## 3.1.1 유령 의존성

대표적인 문제점이 유령 의존성이다. [2.4](/materials/ch_2/item_4_seongwon.md)에서 다룬 것처럼 node modules가 호이스팅되면서
직접 설치한 적은 없지만 참조가 가능한 것을 말한다.

그런데 궁금한 점이 생긴다. 참조할 수 있는게 왜 문제가 되는 것일까?

1. 패키지의 변경에 따라 사용 불가능해질 수 있다.
   예를 들어, A라는 패키지를 설치했는데, 이 패키지가 B에 의존하고 있어서 B도 함께 설치되었다고 가정해보자.
   실수로 B를 직접 설치하지 않은 채 B의 유틸 함수들을 사용했고, 마침 그 함수들이 꽤 유용해서 여러 곳에서 활용했다.
   그런데 몇 개월 후 A 패키지를 업데이트했더니 A가 더 이상 B에 의존하지 않게 되었다. 이 경우, 이전에 사용하던 B의 함수들은 모두 에러를 발생시키게 된다.

   npm 기반 오픈 소스 패키지의 경우 생각보다 이런 사례가 꽤나 많다.

2. 여전히 중첩된 구조가 필요하다.
   평탄화 로직은 유의적 버전이 호환되는 경우에만 작동함으로 유의적 버전이 다르면 중첩된 구조를 가질 수 밖에 없다.
   즉, 서로 다른 버전이 필요할 때 이런 방식은 무의미해진다.

## 3.1.3 너무 거대한 node modules

아래 유명한 밈처럼 패키지를 몇 개만 설치해도 node modules는 기하급수적으로 커진다.

<div align=center>

![node modules meme](../../images/ch_3_1_item_1.png)

</div>

이렇게 커진 node modules는 아래와 같은 문제를 야기한다.

1. 불필요한 디스크 사용
2. 빌드 시간 증가
3. 유효한 검사와 성능 저하

### 3.1.4 변경에 취약한 락 파일

package.lock.json은 동일한 설치 환경을 보장하기 위해 생성된 파일이다. 다른 개발자와 동일한 설치 환경이 얼마나 중요한지는 수 없이 말해도 좋을만큼 중요하다.

npm 공식 문서에 말하는 package.lock.json의 목적은 총 5개로 구분지을 수 있다.

1. 팀원, 배포, CI 환경이 동일한 의존성 트리를 설치할 수 있도록 보장
2. node_modules 폴더를 커밋하지 않고도 의존성 재현 가능
3. 소스 버전 관리 도구에서 변경 사항을 확인할 수 있는 diff 제공
4. npm이 이전에 설치된 패키지의 메타데이터 확인을 건너뛰어 설치 속도를 최적화
5. package.json을 매번 읽지 않아도 되어 성능을 개선

위 목적 모두 중요하지만 문제가 되는 지점은 3번이다.

패키지를 설치하고 나면 package.lock.json changes가 1,000줄 이상 잡혀있는 걸 심심치 않게 볼 수 있다.

이건 결코 장점이 될 수 없다. 이 많은 코드를 리뷰하는 것은 거의 불가능에 가깝기 때문이다.
