<!-- 해당 챕터를 정리한 내용을 적어주세요 -->

# ESModule이란 무엇일까?

> javascript의 공식적인 모듈시스템 <br/>
> 모듈화된 코드를 더욱 일관되고 효율적으로 관리하기 위한 목적으로 도입

## ESModule의 탄생 배경과 도입

**브라우저 환경에서 CommonJS의 한계**

1. 동기적 로딩 방식: CommonJS는 모듈을 동기적으로 로드하는 방식이기 때문에 서버 환경에서는 문제가 없지만 브라우저에서는 로딩 중 블로킹이 발생해 성능 저하를 초래할 수 있다.
2. 프리로딩 불가: CommonJS는 모듈을 미리 로드할 수 없으므로 브라우저에서의 로딩 최적화가 어렵다.
3. 트리 셰이킹 및 최적화 어려움: CommonJS는 런타임에 모듈을 동적으로 로드하기 때문에 의존성 분석이 복잡해지고, 이로 인해 트리 셰이킹과 같은 최적화 작업이 어렵다.
4. 메모리 이슈: CommonJS의 모듈 래퍼는 클로저를 생성해서 각 모듈마다 독립적인 스코프를 제공하는데, 파일이 추가될 때마다 클로저가 생성되어 브라우저에서 메모리 사용량이 증가할 수 있다.
5. 브라우저 호환성 문제: CommonJS는 Node.js 환경을 위해 설계된 시스템이기 때문에 브라우저에서 직접 사용할 수 없다. 이를 해결하려면 Browserify나 Webpack같은 번들링 도구가 필요하며, 서버와 브라우저 간의 모듈 코드 공유가 복잡해진다.

CommonJS가 브라우저 환경을 고려하지 않은 모듈 시스템이기 때문에 자바스크립트의 표준 모듈 시스템으로 자리 잡지 못했다.
대신, ES6에서는 브라우저와 서버 모두 일관되게 사용할 수 있는 표준 모듈 시스템으로 ESModule을 도입하게 되었다.

## ESModule의 특징

> import와 export라는 키워드를 통해 모듈을 정의하고 관리한다.

`export`: 모듈 내에서 특정 변수나 함수를 외부로 내보낼 때 사용
`import`: 다른 모듈에서 내보낸 변수나 함수를 현재 모듈로 가져올 때 사용

### ESModule의 명세

#### export

> 이름으로 내보내기와 기본 내보내기(default export)로 나뉨
> 기본 내보내기는 반드시 하나만 존재

<br/>

**이름으로 내보내기**

- `export {}` 문법을 사용해 공개할 대상을 선언한 식별자를 객체의 속성으로 묶어 내보내는 방식
- 한 파일에서 여러 모듈을 내보낼 때 유용
- 이름으로 내보낸 모듈을 import로 사용한다면 내보낸 이름과 동일한 이름을 사용해야 한다.

  ```
  const a = 1
  const b = 2

  export {a, bs}
  ```

- 대상의 선언문 앞에 export를 추가할 수도 있음
  `  export const a = 1`

**기본 내보내기**

- export 바로 뒤에 default 키워드를 함께 사용하면 기본내보내기
- 하나의 파일당 하나의 대상만 기본으로 내보낼 수 있다.
- 모듈을 가져가는 곳에서 원하는 이름으로 사용할 수 있다.
- export default 문은 마치 "default"라는 변수를 내보낸 것과 유사하다.
  ```
  export default sum;
  export {sum as default}
  ```
  - import 문으로 가져올 때 마치 default라는 모듈을 가져오는 것 처럼 사용할 수 있다.
  ```
  import sum from './module.js'
  import {default as sum} './module.js'
  ```
- export default 문은 사실상 export const default의 문법 설탕

> **Note** 왜 변수 default 내보내기는 안될까
>
> export default const와 같은 형태는 자바스크립트의 문법적 제약으로 인해 불가능.
>
> - 변수 선언이 그 자체로 완성된 표현식이 아닌 선언문이기 때문
>   => 변수선언과 내보내기를 동시에 수행할 수 없도록 설계되어있음
>
> 변수 기본 내보내기를 하고싶다면 다음과 같이 두가지 방법을 사용하면 된다.
>
> ```
> // case1
> const a = 1;
> export default a;
> //case2
> export default 1
> ```

#### import

- import 키워드와 함께 from 키워드를 사용해 가져올 모듈의 출처와 가져올 대상 모듈을 정의할 수 있다.
- 현재 범위에 특정 이름으로 바인딩해서 가져올 수도 있으며 이름으로 내보낸 모듈에서 각각의 멤버를 선택적으로 가져올 수도 있다.
- 이름으로 내보낸 모듈을 가져올 때는 모듈의 식별자를 사용해야 한다.
- import \* as 구문을 사용하면 내보낸 전체 식별자를 포함하는 객체를 가져와서 사용할 수 있다.
- as 키워드로 모듈에 별칭을 부여할 수 있다.
- 기본으로 내보낸 모듈을 가져오는 경우 내보낸 이름과 동일한 식별자를 사용할 필요 없이 원하는 이름으로 사용 가능
- 기본으로 내보낸 모듈을 가져오는 import문은 중괄호 없이 export default의 모듈 내용을 바로 가져올 수 있다.
- 기본으로 가져오는 문법과 이름으로 가져오는 문법을 함께 사용가능
- import는 모듈의 단일 인스턴스를 가져오므로 같은 모듈을 여러번 가져와도 해당 모듈은 한 번만 로드 됨.
  - require()함수로 가져온 모듈을 캐싱해 한번만 로드하는 CommonJs의 특징과 유사하지만 그 방법은 다름

#### import.meta

> ESModule에서는 개발자가 모듈을 정보를 얻을 수 있도록 정보를 제공하는 객체인 import.meta를 지원
>
> - 현재 모듈에 대한 정보를 포함한 특별한 내장객체 (ESModule한정 사용 가능)

import.meta에서 제공하는 속성과 메서드

- import.meta.url: 현재 모듈의 url(파일 경로), 모듈이 로드된 위치를 확인할 수 있음.
- import.meta.resolve(moduleName): 현재 모듈의 url을 기반으로 모듈 지정자를 url로 해석하는 메서드. 인수로 받은 모듈명을 기반으로 완전한 경로 반환
  - 반환된 경로는 동적로딩 Import()의 인수로 사용 가능
  - 경로를 해석하기만 하지, 실제로 모듈을 로드하거나 가져오진 않는다.

#### .mjs 파일 확장자

> 런타임 환경에서 CommonJS와 구분하기 위한 새로운 파일 확장자 .mjs로 끝나는 파일은 모두 ESModule 모듈 시스템으로 해석되며 이 파일들은 ESModule의 문법만 사용할 수 있다.

### 정적 모듈 로딩

> ESModule은 동적으로 모듈을 로드하는 CommonJs와 달리 모듈을 정적으로 로드 => 빌드 시점에 모듈을 가져옴

- 코드가 실행되기 전에 필요한 모듈이 이미 로드되어있으며 번들러가 소스코드를 번들링할 때 모든 의존성을 파악하고 포함시키는 방식
- 빌드된 번들은 추가적인 네트워크 요청이나 로딩 지연 없이 필요한 모든 코드가 사전에 포함

**정적 로드가 동적 로드보다 좋은 점**

- 불필요한 대기 시간 감소: 런타임 중 모듈을 가져오는 대기 시간이 줄어들어 페이지를 초기 로드하는 시간을 단축하고 사용자 경험 향상
- 코드 예측 가능: 코드 간의 의존성 관계를 명확하게 정의하고 예측할 수 있게 함. 어떤 모듈이 언제 로드되는지 명확하게 확인 할 수 있어 코드의 동작을 이해하기 쉽고 유지보수 또한 수월하다.
- 모듈 캐싱과 최적화: 브라우저나 실행 환경에서 모듈을 캐싱하고 최적화 할 수 있음 => 성능 향상
- 의존성 관리 용이: 모듈간의 의존성을 명시적으로 관리할 수 있어 코드의 가독성과 유지 보수성을 향상 시킴
- 번들 최적화: 번들링 보두가 필요한 모듈만 번들에 포함시키고 불필요한 부분을 제거할 수 있게 해 효율적인 번들 생성이 가능함. => 트리 셰이킹이 쉬워 번들 크기를 줄이고 성능 향상에 기여

> **NOTE** ESModule에서 동적 모듈 로드 하는 방법
>
> import() 함수를 쓰자.
>
> ```
> import('./a.js').then((module)=>{
>    // 모듈 사용
> }).catch((error)=>{
>    // 모듈 로드 실패 처리
> })
> ```
>
> 동적으로 가져온 모듈은 Promise를 반환한다. 동적으로 모듈을 가져올 때는 모듈이 실제로 필요한 시점에만 로드되므로 이 작업은 비동기적으로 처리되어야한다.

### 최상위 수준 await

> 모듈 전체가 거대한 하나의 비동기 함수로 동작할 수 있음

```
// todoList.js
let todoList

const response = await fetch('~~/todos')
todoList = await response.json()

export {todoList}
```

```
import {todoList} from './todoList.js'
console.log(todoList)
```

최상위 수준 await를 사용한 todoList를 불러온 index는 todoList에서 비동기 처리가 완료되기 전까지 실행을 멈춤.

비동기 처리가 완료되는 것을 보장하므로 완전히 처리된 결과를 얻을 수 있음

### ESModule의 동작 방식

- 파일 내부의 import문을 따라 파일이 의존하는 다음 모듈을 찾아가면서 의존성 그래프를 구성.
  - 모듈 파싱, 모듈 인스턴스화, 모듈 평가
- 모듈을 불러오는 방법은 사용하는 환경의 로더가 결정

#### 모듈 파싱

- 브라우저나 자바스크립트 엔진이 로드한 모듈 파일을 해석해 모듈 레코드를 생성하고 해당 모듈의 구문과 의존성을 분석 => 모듈 레코드가 생성돼 모듈 로더가 요청 시 해당 모듈을 추적하고 관리할 수 있음
  - 모듈 레코드: 실제 메모리에 로드된 모듈의 값을 관리하는 구조체. 자바스크립트 엔진이 모듈의 상태를 관리하고 의존성을 추적하는데 사용
- 모듈 생성 도중 문법적으로 유효한지 확인하고 모듈의 구조를 이해함

1. 문법검사
2. 토큰화 : 소스코드를 토큰이라는 작은 단위로 분할하는 과정
3. 구문 분석: 문법적 구조 이해
4. 의존성 분석

#### 모듈 인스턴스화

- 모듈의 export된 값들이 메모리에 할당되고 초기화하는 단계
- 사용가능한 상태가 되며 해당 모듈에서 import된 기능들도 메모리에 로드됨
- 모듈 레코드에 모듈 정보를 업데이트해서 export와 import문이 해석되고 필요한 값들이 메모리에 할당되며 모듈 간 참조가 연결된다.
  => 의존성 해결
- export와 import가 동일한 메모리 주소를 참조하기 때문에 모든 import문과 해당 export문이 동기화된 상태로 연결 됨
  - export문 정보를 통해 깊이 우선 탐색해 의존성의 끝까지 탐색하고 모든 export 연결을 완료한다, 이후 역탐색으로 import 항목을 연결함
- ESModule은 export와 import가 동일한 메모리 주소를 참조하기 때문에 내보낸 모듈의 값이 변경되면 가져온 모듈들에 자동반영된다.

### 모듈 평가

- 코드가 실제 실행되며 모듈내의 모든 코드가 평가되며 export된 값들이 최종적인 결괏값을 가짐

#### 동작 방식 정리

1. ESModule은 코드를 분석해 추상 구문 트리로 파싱하고 import 문을 통해 모듈간의 의존성을 사전에 파악한 다음 모듈 레코드라는 일종의 의존성 그래프를 생성.
2. 모듈 인스턴스화 단계에서 필요한 모듈의 메모리 주소를 설정.
3. 모듈 평가 단계에서 코드를 실제로 실행

### ESModule의 순환 참조

> Promise 활용

- 모듈을 가져오는 동안 순환참조가 발생하더라도 Promise를 사용해 무한 루프에 빠지지 않고 처리할 수 있음

```
// a.mjs
import B from './b.mjs'
console.log('A 실행됨')
export default 'A'
```

```
// b.mjs
import A from './a.mjs'
console.log('B 실행됨')
export default 'B'
```

1. A모듈이 B모듈을 가져오는 시점에 B모듈의 평가가 완료되지 않아서 Promise 반환
2. B모듈에서 A모듈을 가졀 때 A모듈은 이미 로드 상태로 간주되어 Promise가 아닌 실제 참조 반환

```
결과:
B가 실행됨,
A가 실행됨.
```

단, 모듈 로드 전 값에 접근하면 문제가 생긴다.

```
//a.mjs
import B from './b.mjs'
export default 1
```

```
//b.mjs
import A from './a.mjs'
console.log('B 실행')
export default A + 1; // Cannot Access "A" before initialization
```

1. a.mjs로드되며 B를 가져오려 하지만 아직 로드 전으로 Promise반환
2. b.mjs로드되며 A모듈을 가져오려 하지만 A는 아직 초기화 되지 않음
3. b.mjs가 A의 값을 사용하려고 시도하면서 A가 초기화되지 않아 오류 발생

## Node.js의 ESModule

Node.js가 ESModule을 지원하게 된 배경

1. 표준화: ESModule는 브라우저에서 이미 널리 지원되고 있는 표준 모듈 시스템. Node.js도 지원하게 되면 자바스크립트 생태계 전반에서 서버와 클라이언트가 같은 모듈 시스템을 사용할 수 있게 됨
2. 성능최적화: ESModule는 트리 셰이킹 등 최적화 기법을 적용하기에 유리

### ESModule 로더

Node.js에서 ESModule 로더의 특징

1. 비동기적 로딩: ESModule로더는 비동기로 동작하며, 필요한 시점에 모듈을 로드해 다른 코드의 실행을 차단하지 않음 (CommonJS는 동기적)
2. 몽키 패치 불가: import 키워드는 재정의가 불가능해 ESModule의 동작 수정 불가능 (require()함수는 재정의 가능한 함수)
3. 폴더 모듈 사용 불가: 인덱스 파일을 명시적으로 지정해야함 (CommonJS는 알아서 찾아감)
4. 확장자 명시 필요 : 반드시 파일 확장자 명시 필요
5. CommonJS와의 상호운용성: require()함수는 ESModule을 로드할 수 없지만 ESModule 로더는 CommonJS 모듈을 로드할 수 있다.

### ESModule 파일 규칙

> Node.js가 ESModule모듈 시스템으로 해석할지 결정하는 기준

1. .mjs 확장자로 끝나는 파일
2. 가장 가까운 상위 package.json의 'type'필드가 'module'인 하위 .js파일
3. --eval이나 STDIN으로 실행 시 --input-type=module 플래그 사용
4. --experimental-detect-module 옵션을 사용한 경우

### import.meta

> Node.js는 ESModule에서 import.meta객체를 지원함.

#### import.meta.url

file://로 시작하는 절대 경로 형태의 url로 반환.
모듈이 위치한 디렉터리나 특정 경로를 참조할 때 활용

혹은 경로를 조작할 수 있음.

#### import.meta.dirname과 import.meta.filename

- 간단하게 모듈의 디렉터리 경로와 파일 경로를 얻을 수 있는 속성
- 없었을 때는 매번 import.meta.url를 파일 경로로 변환해서 파싱했음

#### import.meta. resolve(specifier)

- 특정 모듈 경로를 해석해 URL 형색의 절대 경로로 변환해주는 비동기 함수
- 가끔 변환된 경로와 실제 파일 시스템상 경로가 일치하지 않는 경우가 있으니 파일 위치를 정확하게 확인해야함

### CommonJS와의 상호운용성

> 상호운용성이란? 새로운 기능을 추가하거나 기존 코드를 개선할 때 기존 코드를 다시 작성하지 않고도 모듈을 쉽게 취가하거나 교체할 수 있는 기능

- Node.js는 기존 CommonJS와 새로운 ESModule를 함께 사용할 수 있는 방향으로 구현했다.

#### import문과 require()함수

- CommonJS는 동기적으로 가져오지만 ESModule는 비동기적으로 가져옴
- ESModule로 전환하려면 require()을 import로 전환해야함.
  - 동기vs비동기 로딩, 전역 객체 차이, 환경설정의 이유로 코드가 정상적으로 동작하지 않을 수 있음
- ESModule에서는 CommonJS를 호출할때 그냥 import문을 사용하던지 import() 함수로 동적로드한다.
- CommonJS에서는 import()함수로 로드한다. require()함수로는 불가능한다.(ESModule는 비동기적 로드)

#### CommonJS 네임스페이스

- CommonJS는 module.exports 객체에 내보낼 대상 모듈을 포함시키지만 ESModule는 export문을 사용함
- CommonJS는 모듈 래퍼로 감싸 스코프를 분리해 내보내며 의존성은 런타임에 해결하지만 ESModule은 export문을 동작방식에 따라 해석해 정적으로 의존성 해결

- CommonJS에서 module.exports로 내보낸 것은 ESModule의 기본내보내기와 동일해 import문으로 가져올 수있다.
  - 이름으로 내보내기처럼 가져오려면 CommonJS에서 exports 객체로 내보내면 된다.
  - exports 객체로 내보낸 객체는 module.exports로 객체를 내보낸 것과 동일하므로 이 또한 기본 가져오기로 모듈을 가져오는 것도 가능
  - CommonJS 모듈을 가져올 때는 그 모듈이 이름으로 내보내기를 제공하는지를 반드시 확인해야함. 가장 안전한 방법은 무조건 기본가져오기를 사용하는 것

